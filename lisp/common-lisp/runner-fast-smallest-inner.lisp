(defpackage :pp-runner-fast-smallest-inner
  (:use :cl)
  (:export :main))
(in-package :pp-runner-fast-smallest-inner)

(load "../gc.lisp")
(load "args.lisp")

(declaim (ftype (function (pp-fast::word32 pp-fast::word32 pp-fast::word32)
                          (values pp-fast::word32 (unsigned-byte 64)))
                %do-iters))

(defun %do-iters (min max iters)
  (declare (type pp-fast::word32 min max iters))
  (let* ((acc 0)
         (cnt 0)
         (current-min min))
    (declare (type (unsigned-byte 64) acc cnt)
             (type pp-fast::word32 current-min))
    (loop for n of-type pp-fast::word32 from 0 below iters do
      (multiple-value-bind (p vec) (pp-fast:smallest-inner current-min max)
        (when p
          (let ((sum 0))
            (declare (type (unsigned-byte 64) sum)
                     (type (simple-array (unsigned-byte 32) (*)) vec)
                     (type pp-fast::word32 p))
            (setf sum (the pp-fast::word64 (pp-fast::sum-ub32-vector vec)))
            (incf acc (+ sum (the pp-fast::word64 p) cnt))
            (incf cnt))))
      (setf current-min (if (>= current-min max)
                            min
                            (the pp-fast::word32 (1+ current-min)))))
    (multiple-value-bind (p _vec) (pp-fast:smallest-inner min max)
      (declare (ignore _vec))
      (values (or p 0) acc))))

(defmacro with-fast-command-parse ((line cmd a b) &body body)
  (let ((s (gensym "S")) (len (gensym "LEN"))
        (sp1 (gensym "SP1")) (sp2 (gensym "SP2"))
        (sp3 (gensym "SP3")) (end-a (gensym "END-A")))
    `(let* ((,s ,line)
            (,len (length ,s)))
       (declare (type simple-string ,s)
                (type fixnum ,len)
                (optimize (speed 3) (safety 0) (debug 0)))
       (let* ((,sp1 (position #\Space ,s :start 0 :end ,len))
              (,sp2 (and ,sp1 (position #\Space ,s :start (1+ ,sp1) :end ,len)))
              (,sp3 (and ,sp2 (position #\Space ,s :start (1+ ,sp2) :end ,len)))
              (,cmd (if ,sp1 (subseq ,s 0 ,sp1) ,s))
              (,end-a (or ,sp2 ,len))
              (,a (and ,sp1 (parse-integer ,s :start (1+ ,sp1) :end ,end-a)))
              (,b (and ,sp2 (parse-integer ,s :start (1+ ,sp2) :end (or ,sp3 ,len)))))
         ,@body))))

(defun server-loop ()
  (pp-gc:prepare-gc-for-bench)
  (let ((min nil) (max nil))
    (loop for line = (read-line *standard-input* nil nil)
          while line do
            (with-fast-command-parse (line cmd a b)
              (cond
                ((and (>= (length cmd) 4) (string= cmd "INIT" :end1 4))
                 (setf min a max b)
                 (format t "OK~%") (finish-output))
                ((and (>= (length cmd) 6) (string= cmd "WARMUP" :end1 6))
                 (when (and min max) (%do-iters min max a))
                 (format t "OK~%") (finish-output))
                ((and (>= (length cmd) 3) (string= cmd "RUN" :end1 3))
                 (if (and min max)
                     (multiple-value-bind (p acc) (%do-iters min max a)
                       (format t "OK ~A ~A~%" p acc))
                     (format t "ERR NOTINIT~%"))
                 (finish-output))
                ((and (>= (length cmd) 4) (string= cmd "QUIT" :end1 4)) (return))
                (t (format t "ERR BADCMD~%") (finish-output)))))))

(defun main ()
  (let* ((argv #+sbcl sb-ext:*posix-argv*))
    (if (and argv (find "--server" argv :test #'string=))
        (server-loop)
        (multiple-value-bind (min max iters) (pp-args:parse-min-max-iters)
          (pp-gc:prepare-gc-for-bench)
          (format t "~D~%" (%do-iters min max iters))))))


