(defpackage :coalton-palindrome-smallest
  (:use :cl)
  (:export :main))
(in-package :coalton-palindrome-smallest)

;; Override Coalton's library optimization settings to disable safety checks
(declaim (optimize (speed 3) (safety 0) (debug 0)))

(load "../gc.lisp")

(defun %do-iters (min max iters)
  (declare (type fixnum min max iters))
  (let ((result (coalton-palindrome:do-iters-smallest min max iters)))
    (values (coalton-library/tuple:fst result) (coalton-library/tuple:snd result))))

(defun server-loop ()
  (pp-gc:prepare-gc-for-bench)
  (let ((min nil) (max nil))
    (loop for line = (read-line *standard-input* nil nil)
          while line do
            (let* ((parts (uiop:split-string line :separator " "))
                   (cmd   (string-upcase (first parts))))
              (cond
                ((string= cmd "INIT")
                 (setf min (parse-integer (second parts))
                       max (parse-integer (third parts)))
                 (format t "OK~%") (finish-output))
                ((string= cmd "WARMUP")
                 (let ((iters (parse-integer (second parts))))
                   (when (and min max) (%do-iters min max iters))
                   (format t "OK~%") (finish-output)))
                ((string= cmd "RUN")
                 (let ((iters (parse-integer (second parts))))
                   (if (and min max)
                       (multiple-value-bind (p acc) (%do-iters min max iters)
                         (format t "OK ~D ~D~%" p acc))
                       (format t "ERR NOTINIT~%"))
                   (finish-output)))
                ((string= cmd "QUIT") (return))
                (t (format t "ERR BADCMD~%") (finish-output)))))))

(defun main ()
  (let* ((argv #+sbcl sb-ext:*posix-argv*))
    (if (and argv (find "--server" argv :test #'string=))
        (server-loop)
        (let* ((args (subseq argv (- (length argv) 3))))
          (unless (= (length args) 3)
            (format t "usage: ~A <min> <max> <iterations>~%" (first argv))
            (uiop:quit 2))
          (pp-gc:prepare-gc-for-bench)
          (let ((min (parse-integer (first args)))
                (max (parse-integer (second args)))
                (iters (max 1 (parse-integer (third args)))))
            (format t "~D~%" (%do-iters min max iters)))))))
