#+TITLE: Palindromic Products Benchmarking
#+AUTHOR: Peter Farr

* Overview
This project compares different implementations of the "palindromic products"
coding challenge, originally from Exercism (https://exercism.org).

** The problem
Given a range of integers [min, max], find:
- the smallest palindromic product of two factors in that range
- the largest palindromic product of two factors in that range

A palindromic product is a product whose decimal representation is a palindrome.

Each function returns:
1. The palindrome value itself
2. The list of factor pairs that generate it

** The goal
We implement and benchmark solutions in Common Lisp (SBCL), Rust, Go, and Haskell.
The objective is to measure performance trade-offs across languages and
algorithmic optimizations.

* Project layout
- =lisp/= Common Lisp implementations and build scripts
- =rust-palindrome/= Rust solution binaries and library
- =go-palindrome/= Go solution binaries and library
- =haskell-palindrome/= Haskell solution binaries and library
- =palindrome-benchmark/= Criterion harness that drives all binaries
- =target-bin/= where all compiled executables are collected

* Benchmark Runner Design

The benchmark runners use a sophisticated iteration strategy to prevent compiler elision and ensure fair comparisons:

** Range-Based Iteration
Instead of running the same range repeatedly, the runners iterate across different ranges:
- =Smallest=: Varies =min= from =min= to =max= while keeping =max= constant
- =Largest=: Varies =max= from =max= to =min= while keeping =min= constant

** Accumulator Anti-Elision Trick
To ensure the compiler doesn't optimize away the work, each iteration:
1. Computes the palindrome result for the current range
2. Extracts the product and factor pairs from the result
3. Sums the factor pairs into a running accumulator
4. Adds the product, factor sum, and iteration counter to the accumulator
5. Returns both the final product and accumulator to prove work was done

This approach ensures that:
- Each iteration processes a different range (preventing memoization)
- The accumulator value changes on every iteration (preventing elision)
- The final accumulator value is returned and printed (proving work was done)

** Mathematical Distribution
For =N= total iterations across =R= ranges:
- Each range runs =N ÷ R= times (base iterations)
- The first =N mod R= ranges run one additional time (remainder iterations)
- Total iterations = =(N ÷ R) × R + (N mod R) = N= (exactly)

* Build all binaries (Lisp, Rust, Go, then Haskell)

** Common Lisp (SBCL)
From the =lisp/= directory, run each build script with SBCL like this:

#+BEGIN_SRC shell
cd lisp

sbcl --dynamic-space-size 4096 --noinform --disable-debugger --non-interactive \
     --load build-fast-smallest-inner.lisp

sbcl --dynamic-space-size 4096 --noinform --disable-debugger --non-interactive \
     --load build-fast-largest-inner.lisp
#+END_SRC

Each command produces executables in =target-bin/=:
- palprod-fast-smallest-inner
- palprod-fast-largest-inner

** Rust
Build the Rust solution in release mode, then copy the binaries to =target-bin/=:

#+BEGIN_SRC shell
cd rust-palindrome
RUSTFLAGS="-C target-cpu=native" cargo build --release

cp target/release/palprod-rust-smallest ../target-bin/
cp target/release/palprod-rust-largest  ../target-bin/
#+END_SRC

** Go
Build the Go solution and copy the binaries to =target-bin/=:

#+BEGIN_SRC shell
cd go-palindrome
./build.sh
#+END_SRC

** Haskell
Build the Haskell solution and copy the binaries to =target-bin/=:

#+BEGIN_SRC shell
cd haskell-palindrome
./build.sh
#+END_SRC

After these steps, =target-bin/= should contain eight executables:
- palprod-fast-smallest-inner
- palprod-fast-largest-inner
- palprod-rust-smallest
- palprod-rust-largest
- palprod-go-smallest
- palprod-go-largest
- palprod-haskell-smallest
- palprod-haskell-largest

* Benchmark harness design

To ensure fair comparisons, we benchmark by shelling out to fully compiled
executables. This avoids bias from interpreter startup or compilation latency.

Criterion (in =palindrome-benchmark/=) runs each binary via a small harness that
acts like a "server": it performs warmups, then repeated timed runs. By
amortizing the process startup cost, the measurements reflect only the algorithm
runtime, not external overhead. This design makes cross-language benchmarking
much more reliable.

* Run the Criterion suite

The Criterion project expects all executables to already be present in =target-bin/=.

#+BEGIN_SRC shell
cd palindrome-benchmark
RUSTFLAGS="-C target-cpu=native" cargo bench
#+END_SRC

Criterion will run the configured scenarios and report timing distributions and
comparisons.

* Current results

Latest average times per iteration:

| Implementation |    Range | Task     | Time      |
|----------------+----------+----------+-----------|
| Haskell        | 100..999 | largest  | 1.2707 ns |
| Haskell        | 910..999 | smallest | 1.4243 ns |
| Rust           | 100..999 | largest  | 1.3114 µs |
| Rust           | 910..999 | smallest | 2.8651 µs |
| Lisp           | 100..999 | largest  | 1.6564 µs |
| Lisp           | 910..999 | smallest | 3.2423 µs |
| Golang         | 100..999 | largest  | 2.1224 µs |
| Golang         | 910..999 | smallest | 3.4928 µs |

* Notes
- All languages use a numeric half-reversal palindrome check (no strings).
- The Common Lisp code adds type declarations to encourage fixnum arithmetic in SBCL.
- We apply pruning (outer and inner) and early exits (for example divisibility by 11 on even-digit products) to reduce calls to the palindrome predicate.

* Attribution
Problem statement: Exercism, Common Lisp track, Palindrome Products
https://exercism.org/tracks/common-lisp/exercises/palindrome-products

This repository extends the original exercise with performance-focused
implementations and cross-language benchmarks.
