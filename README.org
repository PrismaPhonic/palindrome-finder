#+TITLE: Palindromic Products Benchmarking
#+AUTHOR: Peter Farr

* Overview
This project compares different implementations of the "palindromic products"
coding challenge, originally from Exercism (https://exercism.org).

** The problem
Given a range of integers [min, max], find:
- the smallest palindromic product of two factors in that range
- the largest palindromic product of two factors in that range

A palindromic product is a product whose decimal representation is a palindrome.

Each function returns:
1. The palindrome value itself
2. The list of factor pairs that generate it

** The goal
We implement and benchmark solutions in Common Lisp (SBCL), Rust, Go, and Haskell.
The objective is to measure performance trade-offs across languages and
algorithmic optimizations.

* Project layout
- =lisp/= Common Lisp implementations and build scripts
- =rust-palindrome/= Rust solution binaries and library
- =go-palindrome/= Go solution binaries and library
- =haskell-palindrome/= Haskell solution binaries and library
- =palindrome-benchmark/= Criterion harness that drives all binaries
- =target-bin/= where all compiled executables are collected

* Benchmark Runner Design

The benchmark runners use a sophisticated iteration strategy to prevent compiler elision and ensure fair comparisons:

** Range-Based Iteration
Instead of running the same range repeatedly, the runners iterate across different ranges:
- =Smallest=: Varies =min= from =min= to =max= while keeping =max= constant
- =Largest=: Varies =max= from =max= to =min= while keeping =min= constant

** Accumulator Anti-Elision Trick
To ensure the compiler doesn't optimize away the work, each iteration:
1. Computes the palindrome result for the current range
2. Extracts the product and factor pairs from the result
3. Sums the factor pairs into a running accumulator
4. Adds the product, factor sum, and iteration counter to the accumulator
5. Returns both the final product and accumulator to prove work was done

This approach ensures that:
- Each iteration processes a different range (preventing memoization)
- The accumulator value changes on every iteration (preventing elision)
- The final accumulator value is returned and printed (proving work was done)

** Mathematical Distribution
For =N= total iterations across =R= ranges:
- Each range runs =N ÷ R= times (base iterations)
- The first =N mod R= ranges run one additional time (remainder iterations)
- Total iterations = =(N ÷ R) × R + (N mod R) = N= (exactly)

* Build all binaries (Lisp, Rust, Go, then Haskell)

** Common Lisp (SBCL)
From the =lisp/= directory, run each build script with SBCL like this:

#+BEGIN_SRC shell
cd lisp

sbcl --dynamic-space-size 4096 --noinform --disable-debugger --non-interactive \
     --load build-fast-smallest-inner.lisp

sbcl --dynamic-space-size 4096 --noinform --disable-debugger --non-interactive \
     --load build-fast-largest-inner.lisp
#+END_SRC

Each command produces executables in =target-bin/=:
- palprod-fast-smallest-inner
- palprod-fast-largest-inner

** Rust
Build the Rust solution in release mode, then copy the binaries to =target-bin/=:

#+BEGIN_SRC shell
cd rust-palindrome
RUSTFLAGS="-C target-cpu=native" cargo build --release

cp target/release/palprod-rust-smallest ../target-bin/
cp target/release/palprod-rust-largest  ../target-bin/
#+END_SRC

** Rust (PGO + BOLT via cargo-pgo)
We use `cargo-pgo` to generate PGO profiles and then optimize with BOLT on top of the PGO build. Install from `cargo install cargo-pgo`. You also need `llvm-profdata` and `llvm-bolt` (`cargo-pgo` docs: `https://github.com/Kobzol/cargo-pgo`).

Run the combined pipeline from =rust-palindrome/=:

#+BEGIN_SRC shell
cd rust-palindrome
# Optional: set workload size (defaults shown)
ITERS=15000000 WARMUP=250000 ./pgo_bolt_run.sh
#+END_SRC

This produces the following binaries in =target-bin/=: 
- palprod-rust-smallest-pgo-instrumented
- palprod-rust-smallest-bolt-optimized
- palprod-rust-largest-pgo-instrumented
- palprod-rust-largest-bolt-optimized

Notes:
- We do not keep a standalone PGO-optimized output; BOLT is always applied on top of the PGO build.
- Release symbols are preserved (no strip) for BOLT compatibility.

** Go
Build the Go solution and copy the binaries to =target-bin/=:

#+BEGIN_SRC shell
cd go-palindrome
./build.sh
#+END_SRC

** Haskell
Build the Haskell solution and copy the binaries to =target-bin/=:

#+BEGIN_SRC shell
cd haskell-palindrome
./build.sh
#+END_SRC

After these steps, =target-bin/= should contain eight executables:
- palprod-fast-smallest-inner
- palprod-fast-largest-inner
- palprod-rust-smallest
- palprod-rust-largest
- palprod-go-smallest
- palprod-go-largest
- palprod-haskell-smallest
- palprod-haskell-largest

* Benchmark harness design

To ensure fair comparisons, we benchmark by shelling out to fully compiled
executables. This avoids bias from interpreter startup or compilation latency.

Criterion (in =palindrome-benchmark/=) runs each binary via a small harness that
acts like a "server": it performs warmups, then repeated timed runs. By
amortizing the process startup cost, the measurements reflect only the algorithm
runtime, not external overhead. This design makes cross-language benchmarking
much more reliable.

* Run the Criterion suite

The Criterion project expects all executables to already be present in =target-bin/=.

#+BEGIN_SRC shell
cd palindrome-benchmark
RUSTFLAGS="-C target-cpu=native" cargo bench
#+END_SRC

Criterion will run the configured scenarios and report timing distributions and
comparisons.

* Current results

Latest average times per iteration:

| Implementation    |    Range | Task     | Time      |
|-------------------+----------+----------+-----------|
| Rust              | 100..999 | largest  | 2.0571 µs |
| Rust              | 910..999 | smallest | 3.0715 µs |
| Rust (PGO + Bolt) | 100..999 | largest  | 1.9716 µs |
| Rust (PGO + Bolt) | 910..999 | smallest | 2.4033 µs |
| Lisp              | 100..999 | largest  | 2.3833 µs |
| Lisp              | 910..999 | smallest | 3.4088 µs |
| Golang            | 100..999 | largest  | 2.6557 µs |
| Golang            | 910..999 | smallest | 3.7728 µs |
| Haskell           | 100..999 | largest  | 2.5336 µs |
| Haskell           | 910..999 | smallest | 4.0963 µs |

* Notes
- All languages use a numeric half-reversal palindrome check (no strings).
- The Common Lisp code adds type declarations to encourage fixnum arithmetic in SBCL.
- We apply pruning (outer and inner) and early exits (for example divisibility by 11 on even-digit products) to reduce calls to the palindrome predicate.

* Findings: Haskell performance and call for contributions

Over multiple rounds of alignment and profiling, the Haskell implementation consistently trails Rust, SBCL (Common Lisp), and Go.

I write Rust day to day, and don't know these other languages nearly as well. I'm surprised and would have thought Haskell performance would match or exceed Go. If you are a Haskell dev, I'm sure there are dumb things I did, and better ways to optimize the Haskell solution. Please submit a PR!

* Attribution
Problem statement: Exercism, Common Lisp track, Palindrome Products
https://exercism.org/tracks/common-lisp/exercises/palindrome-products

This repository extends the original exercise with performance-focused
implementations and cross-language benchmarks.
